{"71a7027e-6875-47c6-8c25-ad1ae9d4a8a6": {"type": "escrow", "name": "test", "parameters": {"amount": "1", "release_condition": "1", "currency": "SOL"}, "contract": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::{program::invoke, system_instruction};\n\ndeclare_id!(\"997VZiWWKh77q9mYybNpYenzkHxxSSEsyVhbzQxpxofD\");\n\n#[program]\npub mod escrow {\n    use super::*;\n\n    pub fn initialize(\n        ctx: Context<Initialize>,\n        amount: u64,\n        release_condition: u64,\n    ) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        \n        // Initialize escrow data\n        escrow.initializer = ctx.accounts.initializer.key();\n        escrow.recipient = ctx.accounts.recipient.key();\n        escrow.amount = amount;\n        escrow.release_condition = release_condition;\n        escrow.bump = ctx.bumps.escrow;\n        escrow.is_completed = false;\n        \n        // Transfer funds from initializer to escrow account\n        let transfer_instruction = system_instruction::transfer(\n            &ctx.accounts.initializer.key(),\n            &ctx.accounts.escrow.to_account_info().key(),\n            amount,\n        );\n        \n        invoke(\n            &transfer_instruction,\n            &[\n                ctx.accounts.initializer.to_account_info(),\n                ctx.accounts.escrow.to_account_info(),\n                ctx.accounts.system_program.to_account_info(),\n            ],\n        )?;\n        \n        // Log transaction for registry\n        register_with_registry(\"initialize\", amount, ctx.accounts.initializer.key(), ctx.accounts.recipient.key());\n        \n        Ok(())\n    }\n    \n    pub fn release(ctx: Context<Release>) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        \n        // Verify escrow is not already completed\n        require!(!escrow.is_completed, EscrowError::AlreadyCompleted);\n        \n        // Verify release condition is met\n        require!(\n            ctx.accounts.release_authority.key() == escrow.initializer,\n            EscrowError::UnauthorizedReleaseAttempt\n        );\n        \n        // Mark escrow as completed\n        escrow.is_completed = true;\n        \n        // Transfer funds from escrow to recipient\n        let amount = escrow.amount;\n        **ctx.accounts.escrow.to_account_info().try_borrow_mut_lamports()? = ctx\n            .accounts\n            .escrow\n            .to_account_info()\n            .lamports()\n            .checked_sub(amount)\n            .ok_or(EscrowError::AmountOverflow)?;\n            \n        **ctx.accounts.recipient.try_borrow_mut_lamports()? = ctx\n            .accounts\n            .recipient\n            .lamports()\n            .checked_add(amount)\n            .ok_or(EscrowError::AmountOverflow)?;\n        \n        // Log transaction for registry\n        register_with_registry(\"release\", amount, ctx.accounts.release_authority.key(), ctx.accounts.recipient.key());\n        \n        Ok(())\n    }\n    \n    pub fn cancel(ctx: Context<Cancel>) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        \n        // Verify escrow is not already completed\n        require!(!escrow.is_completed, EscrowError::AlreadyCompleted);\n        \n        // Verify cancellation authority\n        require!(\n            ctx.accounts.initializer.key() == escrow.initializer,\n            EscrowError::UnauthorizedCancellation\n        );\n        \n        // Mark escrow as completed\n        escrow.is_completed = true;\n        \n        // Return funds to initializer\n        let amount = escrow.amount;\n        **ctx.accounts.escrow.to_account_info().try_borrow_mut_lamports()? = ctx\n            .accounts\n            .escrow\n            .to_account_info()\n            .lamports()\n            .checked_sub(amount)\n            .ok_or(EscrowError::AmountOverflow)?;\n            \n        **ctx.accounts.initializer.try_borrow_mut_lamports()? = ctx\n            .accounts\n            .initializer\n            .lamports()\n            .checked_add(amount)\n            .ok_or(EscrowError::AmountOverflow)?;\n        \n        // Log transaction for registry\n        register_with_registry(\"cancel\", amount, ctx.accounts.initializer.key(), ctx.accounts.initializer.key());\n        \n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\n#[instruction(amount: u64, release_condition: u64)]\npub struct Initialize<'info> {\n    #[account(mut)]\n    pub initializer: Signer<'info>,\n    /// CHECK: This is the recipient of the escrow funds\n    pub recipient: AccountInfo<'info>,\n    #[account(\n        init,\n        payer = initializer,\n        space = 8 + Escrow::SIZE,\n        seeds = [\n            b\"escrow\",\n            initializer.key().as_ref(),\n            recipient.key().as_ref(),\n            release_condition.to_le_bytes().as_ref(),\n        ],\n        bump\n    )]\n    pub escrow: Account<'info, Escrow>,\n    pub system_program: Program<'info, System>,\n    /// CHECK: Registry program for logging transactions\n    #[account(constraint = registry_program.key() == REGISTRY_PROGRAM_ID)]\n    pub registry_program: AccountInfo<'info>,\n}\n\n#[derive(Accounts)]\npub struct Release<'info> {\n    #[account(mut)]\n    pub release_authority: Signer<'info>,\n    #[account(\n        mut,\n        seeds = [\n            b\"escrow\",\n            escrow.initializer.as_ref(),\n            escrow.recipient.as_ref(),\n            escrow.release_condition.to_le_bytes().as_ref(),\n        ],\n        bump = escrow.bump,\n        constraint = !escrow.is_completed @ EscrowError::AlreadyCompleted,\n    )]\n    pub escrow: Account<'info, Escrow>,\n    /// CHECK: This is the recipient of the escrow funds\n    #[account(\n        mut,\n        constraint = recipient.key() == escrow.recipient @ EscrowError::InvalidRecipient\n    )]\n    pub recipient: AccountInfo<'info>,\n    /// CHECK: Registry program for logging transactions\n    #[account(constraint = registry_program.key() == REGISTRY_PROGRAM_ID)]\n    pub registry_program: AccountInfo<'info>,\n}\n\n#[derive(Accounts)]\npub struct Cancel<'info> {\n    #[account(\n        mut,\n        constraint = initializer.key() == escrow.initializer @ EscrowError::UnauthorizedCancellation\n    )]\n    pub initializer: Signer<'info>,\n    #[account(\n        mut,\n        seeds = [\n            b\"escrow\",\n            escrow.initializer.as_ref(),\n            escrow.recipient.as_ref(),\n            escrow.release_condition.to_le_bytes().as_ref(),\n        ],\n        bump = escrow.bump,\n        constraint = !escrow.is_completed @ EscrowError::AlreadyCompleted,\n    )]\n    pub escrow: Account<'info, Escrow>,\n    /// CHECK: Registry program for logging transactions\n    #[account(constraint = registry_program.key() == REGISTRY_PROGRAM_ID)]\n    pub registry_program: AccountInfo<'info>,\n}\n\n#[account]\npub struct Escrow {\n    pub initializer: Pubkey,\n    pub recipient: Pubkey,\n    pub amount: u64,\n    pub release_condition: u64,\n    pub is_completed: bool,\n    pub bump: u8,\n}\n\nimpl Escrow {\n    pub const SIZE: usize = 32 + // initializer\n                            32 + // recipient\n                            8 +  // amount\n                            8 +  // release_condition\n                            1 +  // is_completed\n                            1;   // bump\n}\n\n#[error_code]\npub enum EscrowError {\n    #[msg(\"Escrow has already been completed\")]\n    AlreadyCompleted,\n    #[msg(\"Only the initializer can release the funds\")]\n    UnauthorizedReleaseAttempt,\n    #[msg(\"Only the initializer can cancel the escrow\")]\n    UnauthorizedCancellation,\n    #[msg(\"Invalid recipient for escrow release\")]\n    InvalidRecipient,\n    #[msg(\"Amount calculation resulted in overflow\")]\n    AmountOverflow,\n}\n\n// Registry program ID (fixed)\npub const REGISTRY_PROGRAM_ID: Pubkey = pubkey!(\"BhETt1LhzVYpK5DTcRuNZdKyb3QTz8HktUoXQJQapmvn\");\n\n// Helper function to log registry transactions\nfn register_with_registry(tx_type: &str, amount: u64, initiator: Pubkey, target_account: Pubkey) {\n    msg!(\n        \"Registry Transaction: type={}, amount={}, initiator={}, target={}\",\n        tx_type,\n        amount,\n        initiator,\n        target_account\n    );\n}", "deployed": false, "program_id": "997VZiWWKh77q9mYybNpYenzkHxxSSEsyVhbzQxpxofD", "build_success": true}, "c29b346d-76d0-45f9-97c2-4a0b5c758333": {"type": "escrow", "name": "test", "parameters": {"amount": "10", "release_condition": "1000", "currency": "SOL"}, "contract": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::{program::invoke, system_instruction};\n\ndeclare_id!(\"GpsdkAk5vXHAKcZeWFYJnjCitRDCQ3FbNPu1ddseaGoN\");\n\n#[program]\npub mod escrow {\n    use super::*;\n\n    pub fn initialize(\n        ctx: Context<Initialize>,\n        amount: u64,\n        release_condition: u64,\n    ) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        \n        // Initialize escrow data\n        escrow.initializer = ctx.accounts.initializer.key();\n        escrow.recipient = ctx.accounts.recipient.key();\n        escrow.amount = amount;\n        escrow.release_condition = release_condition;\n        escrow.bump = ctx.bumps.escrow;\n        escrow.is_completed = false;\n        \n        // Transfer funds from initializer to escrow account\n        let transfer_instruction = system_instruction::transfer(\n            &ctx.accounts.initializer.key(),\n            &ctx.accounts.escrow.to_account_info().key(),\n            amount,\n        );\n        \n        invoke(\n            &transfer_instruction,\n            &[\n                ctx.accounts.initializer.to_account_info(),\n                ctx.accounts.escrow.to_account_info(),\n                ctx.accounts.system_program.to_account_info(),\n            ],\n        )?;\n        \n        // Log transaction for registry\n        register_with_registry(\n            \"initialize\",\n            amount,\n            ctx.accounts.initializer.key().to_string(),\n            ctx.accounts.escrow.key().to_string(),\n        );\n        \n        Ok(())\n    }\n    \n    pub fn release(ctx: Context<Release>) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        \n        // Verify escrow is not already completed\n        require!(!escrow.is_completed, EscrowError::AlreadyCompleted);\n        \n        // Verify release condition is met\n        require!(\n            ctx.accounts.condition_account.lamports() >= escrow.release_condition,\n            EscrowError::ReleaseConditionNotMet\n        );\n        \n        // Mark escrow as completed\n        escrow.is_completed = true;\n        \n        // Calculate the amount to transfer\n        let amount = escrow.amount;\n        \n        // Transfer funds from escrow to recipient\n        **ctx.accounts.escrow.to_account_info().try_borrow_mut_lamports()? = ctx\n            .accounts\n            .escrow\n            .to_account_info()\n            .lamports()\n            .checked_sub(amount)\n            .ok_or(EscrowError::AmountOverflow)?;\n            \n        **ctx.accounts.recipient.try_borrow_mut_lamports()? = ctx\n            .accounts\n            .recipient\n            .lamports()\n            .checked_add(amount)\n            .ok_or(EscrowError::AmountOverflow)?;\n        \n        // Log transaction for registry\n        register_with_registry(\n            \"release\",\n            amount,\n            ctx.accounts.escrow.key().to_string(),\n            ctx.accounts.recipient.key().to_string(),\n        );\n        \n        Ok(())\n    }\n    \n    pub fn cancel(ctx: Context<Cancel>) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        \n        // Verify escrow is not already completed\n        require!(!escrow.is_completed, EscrowError::AlreadyCompleted);\n        \n        // Mark escrow as completed\n        escrow.is_completed = true;\n        \n        // Calculate the amount to return\n        let amount = escrow.amount;\n        \n        // Transfer funds from escrow back to initializer\n        **ctx.accounts.escrow.to_account_info().try_borrow_mut_lamports()? = ctx\n            .accounts\n            .escrow\n            .to_account_info()\n            .lamports()\n            .checked_sub(amount)\n            .ok_or(EscrowError::AmountOverflow)?;\n            \n        **ctx.accounts.initializer.try_borrow_mut_lamports()? = ctx\n            .accounts\n            .initializer\n            .lamports()\n            .checked_add(amount)\n            .ok_or(EscrowError::AmountOverflow)?;\n        \n        // Log transaction for registry\n        register_with_registry(\n            \"cancel\",\n            amount,\n            ctx.accounts.escrow.key().to_string(),\n            ctx.accounts.initializer.key().to_string(),\n        );\n        \n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(mut)]\n    pub initializer: Signer<'info>,\n    \n    /// CHECK: This is the recipient of the escrow funds\n    pub recipient: UncheckedAccount<'info>,\n    \n    #[account(\n        init,\n        payer = initializer,\n        space = 8 + Escrow::SIZE,\n        seeds = [\n            b\"escrow\",\n            initializer.key().as_ref(),\n            recipient.key().as_ref(),\n        ],\n        bump\n    )]\n    pub escrow: Account<'info, Escrow>,\n    \n    /// CHECK: This is the registry program\n    #[account(\n        address = registry_program_id::ID\n    )]\n    pub registry_program: UncheckedAccount<'info>,\n    \n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Release<'info> {\n    /// CHECK: This is the recipient of the escrow funds\n    #[account(mut)]\n    pub recipient: UncheckedAccount<'info>,\n    \n    #[account(\n        mut,\n        seeds = [\n            b\"escrow\",\n            escrow.initializer.as_ref(),\n            recipient.key().as_ref(),\n        ],\n        bump = escrow.bump,\n        constraint = escrow.recipient == recipient.key() @ EscrowError::InvalidRecipient\n    )]\n    pub escrow: Account<'info, Escrow>,\n    \n    /// CHECK: This account is checked against the release condition\n    pub condition_account: UncheckedAccount<'info>,\n    \n    /// CHECK: This is the registry program\n    #[account(\n        address = registry_program_id::ID\n    )]\n    pub registry_program: UncheckedAccount<'info>,\n    \n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Cancel<'info> {\n    #[account(\n        mut,\n        constraint = escrow.initializer == initializer.key() @ EscrowError::InvalidInitializer\n    )]\n    pub initializer: Signer<'info>,\n    \n    #[account(\n        mut,\n        seeds = [\n            b\"escrow\",\n            initializer.key().as_ref(),\n            escrow.recipient.as_ref(),\n        ],\n        bump = escrow.bump\n    )]\n    pub escrow: Account<'info, Escrow>,\n    \n    /// CHECK: This is the registry program\n    #[account(\n        address = registry_program_id::ID\n    )]\n    pub registry_program: UncheckedAccount<'info>,\n    \n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct Escrow {\n    pub initializer: Pubkey,\n    pub recipient: Pubkey,\n    pub amount: u64,\n    pub release_condition: u64,\n    pub bump: u8,\n    pub is_completed: bool,\n}\n\nimpl Escrow {\n    pub const SIZE: usize = 32 + // initializer\n                            32 + // recipient\n                            8 +  // amount\n                            8 +  // release_condition\n                            1 +  // bump\n                            1;   // is_completed\n}\n\n#[error_code]\npub enum EscrowError {\n    #[msg(\"Escrow has already been completed\")]\n    AlreadyCompleted,\n    \n    #[msg(\"Release condition not met\")]\n    ReleaseConditionNotMet,\n    \n    #[msg(\"Invalid recipient\")]\n    InvalidRecipient,\n    \n    #[msg(\"Invalid initializer\")]\n    InvalidInitializer,\n    \n    #[msg(\"Amount overflow\")]\n    AmountOverflow,\n}\n\n// Registry program ID\nmod registry_program_id {\n    use anchor_lang::declare_id;\n    declare_id!(\"GpsdkAk5vXHAKcZeWFYJnjCitRDCQ3FbNPu1ddseaGoN\");\n}\n\n// Helper function to log registry transactions\nfn register_with_registry(tx_type: &str, amount: u64, initiator: String, target_account: String) {\n    msg!(\n        \"Registry Transaction: type={}, amount={}, initiator={}, target={}\",\n        tx_type,\n        amount,\n        initiator,\n        target_account\n    );\n}", "deployed": false, "program_id": "GpsdkAk5vXHAKcZeWFYJnjCitRDCQ3FbNPu1ddseaGoN", "build_success": true}, "ad8104d9-8a9c-4b40-b509-44a9ddd28e8a": {"type": "escrow", "name": "testing", "parameters": {"amount": "10", "currency": "SOL", "release_condition": "2"}, "contract": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::{program::invoke, system_instruction};\nuse std::str::FromStr;\n\ndeclare_id!(\"2WCyeU1A7BRuTnetbvGe9CA7av1Yty53Pzdn6HrYBohR\");\n\n// Registry integration code\npub const REGISTRY_PROGRAM_ID: &str = \"BhETt1LhzVYpK5DTcRuNZdKyb3QTz8HktUoXQJQapmvn\";\npub const REGISTRY_TRANSACTION_SEED: &str = \"transaction_v1\";\n\n// Structure for Registry transaction data\n#[derive(AnchorSerialize, AnchorDeserialize)]\npub struct RegistryTransactionData {\n    pub tx_type: String,\n    pub amount: u64, \n    pub initiator: Pubkey,\n    pub target_account: Pubkey,\n    pub description: String,\n}\n\n#[program]\npub mod escrow {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, amount: u64, release_condition: String) -> Result<()> {\n        // Initialize escrow account\n        let escrow = &mut ctx.accounts.escrow_account;\n        \n        escrow.sender = ctx.accounts.sender.key();\n        escrow.receiver = ctx.accounts.receiver.key();\n        escrow.escrow_authority = ctx.accounts.escrow_authority.key();\n        escrow.amount = amount;\n        escrow.release_condition = release_condition;\n        escrow.is_completed = false;\n        \n        // Transfer funds from sender to escrow account\n        let transfer_instruction = system_instruction::transfer(\n            &ctx.accounts.sender.key(),\n            &ctx.accounts.escrow_account.key(),\n            amount,\n        );\n        \n        // Clone the account infos before using them to avoid borrow conflicts\n        let sender_info = ctx.accounts.sender.to_account_info();\n        let escrow_account_info = ctx.accounts.escrow_account.to_account_info();\n        let system_program_info = ctx.accounts.system_program.to_account_info();\n        \n        invoke(\n            &transfer_instruction,\n            &[\n                sender_info,\n                escrow_account_info,\n                system_program_info,\n            ],\n        )?;\n        \n        // Register the transaction with the registry program if provided\n        if ctx.accounts.registry_program.key() == Pubkey::from_str(REGISTRY_PROGRAM_ID).unwrap() {\n            let registry_data = RegistryTransactionData {\n                tx_type: \"escrow_initialize\".to_string(),\n                amount,\n                initiator: ctx.accounts.sender.key(),\n                target_account: ctx.accounts.receiver.key(),\n                description: format!(\"Escrow initialized with amount {}\", amount),\n            };\n            \n            // Register the transaction using the helper function\n            register_transaction_helper(\n                ctx.accounts.registry_program.to_account_info(),\n                ctx.accounts.registry_transaction.to_account_info(),\n                ctx.accounts.sender.to_account_info(),\n                ctx.accounts.system_program.to_account_info(),\n                registry_data,\n            )?;\n        }\n        \n        Ok(())\n    }\n\n    pub fn release(ctx: Context<Release>) -> Result<()> {\n        // Get the escrow account info and balance first\n        let escrow_info = ctx.accounts.escrow_account.to_account_info();\n        let escrow_balance = escrow_info.lamports();\n        \n        // Only the escrow authority can release funds\n        require!(\n            ctx.accounts.escrow_authority.key() == ctx.accounts.escrow_account.escrow_authority,\n            EscrowError::UnauthorizedAccess\n        );\n        \n        // Ensure escrow is not already completed\n        require!(!ctx.accounts.escrow_account.is_completed, EscrowError::AlreadyCompleted);\n        \n        // Get the rent to calculate rent-exempt amount\n        let rent = Rent::get()?;\n        \n        // Calculate the rent-exempt amount first\n        let rent_exempt_lamports = rent.minimum_balance(8 + EscrowAccount::SIZE);\n        \n        // Calculate the amount to transfer (total balance minus rent-exempt amount)\n        let transfer_amount = escrow_balance\n            .checked_sub(rent_exempt_lamports)\n            .ok_or(EscrowError::MathOverflow)?;\n        \n        // Transfer funds from escrow account to receiver\n        **escrow_info.try_borrow_mut_lamports()? = rent_exempt_lamports;\n            \n        // Clone receiver info to avoid borrow conflicts\n        let receiver_info = ctx.accounts.receiver.to_account_info();\n        **receiver_info.try_borrow_mut_lamports()? = receiver_info\n            .lamports()\n            .checked_add(transfer_amount)\n            .ok_or(EscrowError::MathOverflow)?;\n        \n        // Mark escrow as completed\n        ctx.accounts.escrow_account.is_completed = true;\n        \n        // Register the transaction with the registry program if provided\n        if ctx.accounts.registry_program.key() == Pubkey::from_str(REGISTRY_PROGRAM_ID).unwrap() {\n            let registry_data = RegistryTransactionData {\n                tx_type: \"escrow_release\".to_string(),\n                amount: transfer_amount,\n                initiator: ctx.accounts.escrow_authority.key(),\n                target_account: ctx.accounts.receiver.key(),\n                description: format!(\"Escrow released with amount {}\", transfer_amount),\n            };\n            \n            // Register the transaction using the helper function\n            register_transaction_helper(\n                ctx.accounts.registry_program.to_account_info(),\n                ctx.accounts.registry_transaction.to_account_info(),\n                ctx.accounts.escrow_authority.to_account_info(),\n                ctx.accounts.system_program.to_account_info(),\n                registry_data,\n            )?;\n        }\n        \n        Ok(())\n    }\n\n    pub fn register_transaction(ctx: Context<RegisterTransaction>, data: RegistryTransactionData) -> Result<()> {\n        // Register the transaction using the helper function\n        register_transaction_helper(\n            ctx.accounts.registry_program.to_account_info(),\n            ctx.accounts.registry_transaction.to_account_info(),\n            ctx.accounts.payer.to_account_info(),\n            ctx.accounts.system_program.to_account_info(),\n            data,\n        )\n    }\n}\n\n// Helper function to register transactions with the registry program\nfn register_transaction_helper<'a>(\n    registry_program: AccountInfo<'a>,\n    registry_transaction: AccountInfo<'a>,\n    payer: AccountInfo<'a>,\n    system_program: AccountInfo<'a>,\n    data: RegistryTransactionData,\n) -> Result<()> {\n    // Serialize the transaction data\n    let mut tx_data = Vec::new();\n    data.serialize(&mut tx_data).map_err(|_| EscrowError::SerializationError)?;\n    \n    // Create cross-program invocation instruction data\n    let mut instruction_data = Vec::new();\n    instruction_data.push(0); // Instruction index for register_transaction\n    instruction_data.extend_from_slice(&tx_data);\n    \n    // Create the instruction\n    let ix = anchor_lang::solana_program::instruction::Instruction {\n        program_id: registry_program.key(),\n        accounts: vec![\n            anchor_lang::solana_program::instruction::AccountMeta::new(registry_transaction.key(), false),\n            anchor_lang::solana_program::instruction::AccountMeta::new(payer.key(), true),\n            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(system_program.key(), false),\n        ],\n        data: instruction_data,\n    };\n    \n    // Invoke the instruction\n    anchor_lang::solana_program::program::invoke(\n        &ix,\n        &[\n            registry_transaction.clone(),\n            payer.clone(),\n            system_program.clone(),\n        ],\n    ).map_err(|_| EscrowError::RegistryError)?;\n    \n    Ok(())\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(mut)]\n    pub sender: Signer<'info>,\n    \n    /// CHECK: This is safe because we only read the key\n    pub receiver: AccountInfo<'info>,\n    \n    /// CHECK: This is the escrow authority who can release funds\n    pub escrow_authority: AccountInfo<'info>,\n    \n    #[account(\n        init,\n        payer = sender,\n        space = 8 + EscrowAccount::SIZE\n    )]\n    pub escrow_account: Account<'info, EscrowAccount>,\n    \n    pub system_program: Program<'info, System>,\n    \n    /// CHECK: This is the registry program\n    pub registry_program: AccountInfo<'info>,\n    \n    /// CHECK: This is the registry transaction account\n    #[account(mut)]\n    pub registry_transaction: AccountInfo<'info>,\n}\n\n#[derive(Accounts)]\npub struct Release<'info> {\n    /// CHECK: This is the receiver who will receive the funds\n    #[account(mut)]\n    pub receiver: AccountInfo<'info>,\n    \n    /// CHECK: This is the escrow authority who controls the release\n    #[account(mut, signer)]\n    pub escrow_authority: AccountInfo<'info>,\n    \n    #[account(mut)]\n    pub escrow_account: Account<'info, EscrowAccount>,\n    \n    pub system_program: Program<'info, System>,\n    \n    /// CHECK: This is the registry program\n    pub registry_program: AccountInfo<'info>,\n    \n    /// CHECK: This is the registry transaction account\n    #[account(mut)]\n    pub registry_transaction: AccountInfo<'info>,\n}\n\n#[derive(Accounts)]\npub struct RegisterTransaction<'info> {\n    /// CHECK: This is the registry program\n    pub registry_program: AccountInfo<'info>,\n    \n    /// CHECK: This is the registry transaction account\n    #[account(mut)]\n    pub registry_transaction: AccountInfo<'info>,\n    \n    #[account(mut)]\n    pub payer: Signer<'info>,\n    \n    pub system_program: Program<'info, System>,\n}\n\n#[account]\n#[derive(Default)]\npub struct EscrowAccount {\n    pub sender: Pubkey,\n    pub receiver: Pubkey,\n    pub escrow_authority: Pubkey,\n    pub amount: u64,\n    pub release_condition: String,\n    pub is_completed: bool,\n}\n\nimpl EscrowAccount {\n    pub const SIZE: usize = 32 + // sender\n                             32 + // receiver\n                             32 + // escrow_authority\n                             8 +  // amount\n                             4 + 100 + // release_condition (max 100 chars)\n                             1;   // is_completed\n}\n\n#[error_code]\npub enum EscrowError {\n    #[msg(\"Unauthorized access\")]\n    UnauthorizedAccess,\n    #[msg(\"Escrow is already completed\")]\n    AlreadyCompleted,\n    #[msg(\"Math overflow error\")]\n    MathOverflow,\n    #[msg(\"Serialization error\")]\n    SerializationError,\n    #[msg(\"Registry program error\")]\n    RegistryError,\n}", "deployed": false, "program_id": "2WCyeU1A7BRuTnetbvGe9CA7av1Yty53Pzdn6HrYBohR", "build_success": true}, "7f2b42f1-e174-45bb-9ecf-cdff2e6d86f3": {"type": "escrow", "name": "testing", "parameters": {"amount": "10", "currency": "SOL", "release_condition": "2"}, "contract": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::{program::invoke, system_instruction};\nuse std::str::FromStr;\n\ndeclare_id!(\"6bxjHnAj8m5Fs6hve9xeLcKyN4b2gGonCnBDsv59DNXQ\");\n\n// Registry integration code\npub const REGISTRY_PROGRAM_ID: &str = \"BhETt1LhzVYpK5DTcRuNZdKyb3QTz8HktUoXQJQapmvn\";\npub const REGISTRY_TRANSACTION_SEED: &str = \"transaction_v1\";\n\n// Structure for Registry transaction data\n#[derive(AnchorSerialize, AnchorDeserialize)]\npub struct RegistryTransactionData {\n    pub tx_type: String,\n    pub amount: u64, \n    pub initiator: Pubkey,\n    pub target_account: Pubkey,\n    pub description: String,\n}\n\n#[program]\npub mod deploy {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, amount: u64, release_condition: String) -> Result<()> {\n        // Initialize escrow account\n        let escrow = &mut ctx.accounts.escrow_account;\n        \n        escrow.sender = ctx.accounts.sender.key();\n        escrow.receiver = ctx.accounts.receiver.key();\n        escrow.escrow_authority = ctx.accounts.escrow_authority.key();\n        escrow.amount = amount;\n        escrow.release_condition = release_condition;\n        escrow.is_completed = false;\n        \n        // Transfer funds from sender to escrow account\n        let transfer_instruction = system_instruction::transfer(\n            &ctx.accounts.sender.key(),\n            &ctx.accounts.escrow_account.key(),\n            amount,\n        );\n        \n        // Clone the account infos before using them to avoid borrow conflicts\n        let sender_info = ctx.accounts.sender.to_account_info();\n        let escrow_account_info = ctx.accounts.escrow_account.to_account_info();\n        let system_program_info = ctx.accounts.system_program.to_account_info();\n        \n        invoke(\n            &transfer_instruction,\n            &[\n                sender_info,\n                escrow_account_info,\n                system_program_info,\n            ],\n        )?;\n        \n        // Register the transaction with the registry program if provided\n        if ctx.accounts.registry_program.key() == Pubkey::from_str(REGISTRY_PROGRAM_ID).unwrap() {\n            let registry_data = RegistryTransactionData {\n                tx_type: \"escrow_initialize\".to_string(),\n                amount,\n                initiator: ctx.accounts.sender.key(),\n                target_account: ctx.accounts.receiver.key(),\n                description: format!(\"Escrow initialized with amount {}\", amount),\n            };\n            \n            // Register the transaction using the helper function\n            register_transaction_helper(\n                ctx.accounts.registry_program.to_account_info(),\n                ctx.accounts.registry_transaction.to_account_info(),\n                ctx.accounts.sender.to_account_info(),\n                ctx.accounts.system_program.to_account_info(),\n                registry_data,\n            )?;\n        }\n        \n        Ok(())\n    }\n\n    pub fn release(ctx: Context<Release>) -> Result<()> {\n        // Get the escrow account info and balance first\n        let escrow_info = ctx.accounts.escrow_account.to_account_info();\n        let escrow_balance = escrow_info.lamports();\n        \n        // Only the escrow authority can release funds\n        require!(\n            ctx.accounts.escrow_authority.key() == ctx.accounts.escrow_account.escrow_authority,\n            EscrowError::UnauthorizedAccess\n        );\n        \n        // Ensure escrow is not already completed\n        require!(!ctx.accounts.escrow_account.is_completed, EscrowError::AlreadyCompleted);\n        \n        // Get the rent to calculate rent-exempt amount\n        let rent = Rent::get()?;\n        \n        // Calculate the rent-exempt amount first\n        let rent_exempt_lamports = rent.minimum_balance(8 + EscrowAccount::SIZE);\n        \n        // Calculate the amount to transfer (total balance minus rent-exempt amount)\n        let transfer_amount = escrow_balance\n            .checked_sub(rent_exempt_lamports)\n            .ok_or(EscrowError::MathOverflow)?;\n        \n        // Transfer funds from escrow account to receiver\n        **escrow_info.try_borrow_mut_lamports()? = rent_exempt_lamports;\n            \n        // Clone receiver info to avoid borrow conflicts\n        let receiver_info = ctx.accounts.receiver.to_account_info();\n        **receiver_info.try_borrow_mut_lamports()? = receiver_info\n            .lamports()\n            .checked_add(transfer_amount)\n            .ok_or(EscrowError::MathOverflow)?;\n        \n        // Mark escrow as completed\n        ctx.accounts.escrow_account.is_completed = true;\n        \n        // Register the transaction with the registry program if provided\n        if ctx.accounts.registry_program.key() == Pubkey::from_str(REGISTRY_PROGRAM_ID).unwrap() {\n            let registry_data = RegistryTransactionData {\n                tx_type: \"escrow_release\".to_string(),\n                amount: transfer_amount,\n                initiator: ctx.accounts.escrow_authority.key(),\n                target_account: ctx.accounts.receiver.key(),\n                description: format!(\"Escrow released with amount {}\", transfer_amount),\n            };\n            \n            // Register the transaction using the helper function\n            register_transaction_helper(\n                ctx.accounts.registry_program.to_account_info(),\n                ctx.accounts.registry_transaction.to_account_info(),\n                ctx.accounts.escrow_authority.to_account_info(),\n                ctx.accounts.system_program.to_account_info(),\n                registry_data,\n            )?;\n        }\n        \n        Ok(())\n    }\n\n    pub fn register_transaction(ctx: Context<RegisterTransaction>, data: RegistryTransactionData) -> Result<()> {\n        // Register the transaction using the helper function\n        register_transaction_helper(\n            ctx.accounts.registry_program.to_account_info(),\n            ctx.accounts.registry_transaction.to_account_info(),\n            ctx.accounts.payer.to_account_info(),\n            ctx.accounts.system_program.to_account_info(),\n            data,\n        )\n    }\n}\n\n// Helper function to register transactions with the registry program\nfn register_transaction_helper<'a>(\n    registry_program: AccountInfo<'a>,\n    registry_transaction: AccountInfo<'a>,\n    payer: AccountInfo<'a>,\n    system_program: AccountInfo<'a>,\n    data: RegistryTransactionData,\n) -> Result<()> {\n    // Serialize the transaction data\n    let mut tx_data = Vec::new();\n    data.serialize(&mut tx_data).map_err(|_| EscrowError::SerializationError)?;\n    \n    // Create cross-program invocation instruction data\n    let mut instruction_data = Vec::new();\n    instruction_data.push(0); // Instruction index for register_transaction\n    instruction_data.extend_from_slice(&tx_data);\n    \n    // Create the instruction\n    let ix = anchor_lang::solana_program::instruction::Instruction {\n        program_id: registry_program.key(),\n        accounts: vec![\n            anchor_lang::solana_program::instruction::AccountMeta::new(registry_transaction.key(), false),\n            anchor_lang::solana_program::instruction::AccountMeta::new(payer.key(), true),\n            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(system_program.key(), false),\n        ],\n        data: instruction_data,\n    };\n    \n    // Invoke the instruction\n    anchor_lang::solana_program::program::invoke(\n        &ix,\n        &[\n            registry_transaction.clone(),\n            payer.clone(),\n            system_program.clone(),\n        ],\n    ).map_err(|_| EscrowError::RegistryError)?;\n    \n    Ok(())\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(mut)]\n    pub sender: Signer<'info>,\n    \n    /// CHECK: This is safe because we only read the key\n    pub receiver: AccountInfo<'info>,\n    \n    /// CHECK: This is the escrow authority who can release funds\n    pub escrow_authority: AccountInfo<'info>,\n    \n    #[account(\n        init,\n        payer = sender,\n        space = 8 + EscrowAccount::SIZE\n    )]\n    pub escrow_account: Account<'info, EscrowAccount>,\n    \n    pub system_program: Program<'info, System>,\n    \n    /// CHECK: This is the registry program\n    pub registry_program: AccountInfo<'info>,\n    \n    /// CHECK: This is the registry transaction account\n    #[account(mut)]\n    pub registry_transaction: AccountInfo<'info>,\n}\n\n#[derive(Accounts)]\npub struct Release<'info> {\n    /// CHECK: This is the receiver who will receive the funds\n    #[account(mut)]\n    pub receiver: AccountInfo<'info>,\n    \n    /// CHECK: This is the escrow authority who controls the release\n    #[account(mut, signer)]\n    pub escrow_authority: AccountInfo<'info>,\n    \n    #[account(mut)]\n    pub escrow_account: Account<'info, EscrowAccount>,\n    \n    pub system_program: Program<'info, System>,\n    \n    /// CHECK: This is the registry program\n    pub registry_program: AccountInfo<'info>,\n    \n    /// CHECK: This is the registry transaction account\n    #[account(mut)]\n    pub registry_transaction: AccountInfo<'info>,\n}\n\n#[derive(Accounts)]\npub struct RegisterTransaction<'info> {\n    /// CHECK: This is the registry program\n    pub registry_program: AccountInfo<'info>,\n    \n    /// CHECK: This is the registry transaction account\n    #[account(mut)]\n    pub registry_transaction: AccountInfo<'info>,\n    \n    #[account(mut)]\n    pub payer: Signer<'info>,\n    \n    pub system_program: Program<'info, System>,\n}\n\n#[account]\n#[derive(Default)]\npub struct EscrowAccount {\n    pub sender: Pubkey,\n    pub receiver: Pubkey,\n    pub escrow_authority: Pubkey,\n    pub amount: u64,\n    pub release_condition: String,\n    pub is_completed: bool,\n}\n\nimpl EscrowAccount {\n    pub const SIZE: usize = 32 + // sender\n                             32 + // receiver\n                             32 + // escrow_authority\n                             8 +  // amount\n                             4 + 100 + // release_condition (max 100 chars)\n                             1;   // is_completed\n}\n\n#[error_code]\npub enum EscrowError {\n    #[msg(\"Unauthorized access\")]\n    UnauthorizedAccess,\n    #[msg(\"Escrow is already completed\")]\n    AlreadyCompleted,\n    #[msg(\"Math overflow error\")]\n    MathOverflow,\n    #[msg(\"Serialization error\")]\n    SerializationError,\n    #[msg(\"Registry program error\")]\n    RegistryError,\n}", "deployed": false, "program_id": "6bxjHnAj8m5Fs6hve9xeLcKyN4b2gGonCnBDsv59DNXQ", "build_success": true}}