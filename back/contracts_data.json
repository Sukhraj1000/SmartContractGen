{"643ddfd6-4839-41ff-8e9c-fdf2e1c22a21": {"type": "escrow", "name": "testing", "parameters": {"amount": "1", "currency": "SOL", "release_condition": "1"}, "contract": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::{program::invoke, system_instruction::transfer};\n\ndeclare_id!(\"8ZFFnMRvft9ap3iZdX1VqhWXi9pjENZ8TdRCB7V3E9wd\");\n\n#[program]\npub mod escrow {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, amount: u64, release_condition: u64) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        escrow.amount = amount;\n        escrow.release_condition = release_condition;\n        escrow.sender = *ctx.accounts.sender.key;\n        escrow.recipient = *ctx.accounts.recipient.key;\n\n        let transfer_ix = transfer(\n            &ctx.accounts.sender.key,\n            &ctx.accounts.vault.key,\n            amount,\n        );\n\n        invoke(\n            &transfer_ix,\n            &[\n                ctx.accounts.sender.to_account_info(),\n                ctx.accounts.vault.to_account_info(),\n                ctx.accounts.system_program.to_account_info(),\n            ],\n        )?;\n\n        Ok(())\n    }\n\n    pub fn release(ctx: Context<Release>) -> Result<()> {\n        let escrow = &ctx.accounts.escrow;\n\n        if escrow.release_condition != 1 {\n            return Err(ErrorCode::IncorrectReleaseCondition.into());\n        }\n\n        let transfer_ix = transfer(\n            &ctx.accounts.vault.key,\n            &ctx.accounts.recipient.key,\n            escrow.amount,\n        );\n\n        invoke(\n            &transfer_ix,\n            &[\n                ctx.accounts.vault.to_account_info(),\n                ctx.accounts.recipient.to_account_info(),\n                ctx.accounts.system_program.to_account_info(),\n            ],\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = sender, space = 8 + 32 + 32 + 8 + 8)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub sender: Signer<'info>,\n    /// CHECK: This is not dangerous because we don't read or write from this account\n    pub recipient: AccountInfo<'info>,\n    #[account(mut)]\n    pub vault: SystemAccount<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Release<'info> {\n    #[account(mut, has_one = recipient)]\n    pub escrow: Account<'info, Escrow>,\n    #[account(mut)]\n    pub recipient: SystemAccount<'info>,\n    #[account(mut)]\n    pub vault: SystemAccount<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct Escrow {\n    pub sender: Pubkey,\n    pub recipient: Pubkey,\n    pub amount: u64,\n    pub release_condition: u64,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"Incorrect release condition\")]\n    IncorrectReleaseCondition,\n}", "deployed": false, "program_id": "8ZFFnMRvft9ap3iZdX1VqhWXi9pjENZ8TdRCB7V3E9wd", "build_success": true}, "959fe205-2b74-41d0-9902-bef296370935": {"type": "escrow", "name": "sk", "parameters": {"amount": "1", "release_condition": "2", "currency": "SOL"}, "contract": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::{program::invoke, system_instruction};\n\ndeclare_id!(\"8dfHZMcSAqoryDtza2qpHGqLEHy5c54M8qe7qTYQc1x6\");\n\n#[program]\npub mod escrow {\n    use super::*;\n\n    pub fn initialize(\n        ctx: Context<Initialize>,\n        amount: u64,\n        release_condition: u64,\n    ) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        escrow.initializer = ctx.accounts.initializer.key();\n        escrow.recipient = ctx.accounts.recipient.key();\n        escrow.amount = amount;\n        escrow.release_condition = release_condition;\n        escrow.bump = ctx.bumps.escrow;\n        escrow.is_completed = false;\n\n        // Transfer funds from initializer to escrow account\n        let transfer_instruction = system_instruction::transfer(\n            &ctx.accounts.initializer.key(),\n            &ctx.accounts.escrow.to_account_info().key(),\n            amount,\n        );\n\n        invoke(\n            &transfer_instruction,\n            &[\n                ctx.accounts.initializer.to_account_info(),\n                ctx.accounts.escrow.to_account_info(),\n                ctx.accounts.system_program.to_account_info(),\n            ],\n        )?;\n\n        // Log transaction for registry\n        register_with_registry(\n            \"initialize\",\n            amount,\n            ctx.accounts.initializer.key().to_string(),\n            ctx.accounts.recipient.key().to_string(),\n        );\n\n        Ok(())\n    }\n\n    pub fn release(ctx: Context<Release>) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        \n        // Verify escrow account\n        require!(!escrow.is_completed, EscrowError::AlreadyCompleted);\n        require!(\n            escrow.release_condition <= Clock::get()?.unix_timestamp as u64,\n            EscrowError::ConditionNotMet\n        );\n\n        // Mark as completed\n        escrow.is_completed = true;\n\n        // Calculate the amount to transfer\n        let amount = escrow.amount;\n\n        // Transfer funds from escrow account to recipient\n        **ctx.accounts.escrow.to_account_info().try_borrow_mut_lamports()? = ctx\n            .accounts\n            .escrow\n            .to_account_info()\n            .lamports()\n            .checked_sub(amount)\n            .ok_or(EscrowError::AmountOverflow)?;\n\n        **ctx.accounts.recipient.try_borrow_mut_lamports()? = ctx\n            .accounts\n            .recipient\n            .lamports()\n            .checked_add(amount)\n            .ok_or(EscrowError::AmountOverflow)?;\n\n        // Log transaction for registry\n        register_with_registry(\n            \"release\",\n            amount,\n            ctx.accounts.escrow.key().to_string(),\n            ctx.accounts.recipient.key().to_string(),\n        );\n\n        Ok(())\n    }\n\n    pub fn cancel(ctx: Context<Cancel>) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        \n        // Verify escrow account\n        require!(!escrow.is_completed, EscrowError::AlreadyCompleted);\n        require!(\n            escrow.initializer == ctx.accounts.initializer.key(),\n            EscrowError::Unauthorized\n        );\n\n        // Mark as completed\n        escrow.is_completed = true;\n\n        // Calculate the amount to transfer\n        let amount = escrow.amount;\n\n        // Transfer funds from escrow account back to initializer\n        **ctx.accounts.escrow.to_account_info().try_borrow_mut_lamports()? = ctx\n            .accounts\n            .escrow\n            .to_account_info()\n            .lamports()\n            .checked_sub(amount)\n            .ok_or(EscrowError::AmountOverflow)?;\n\n        **ctx.accounts.initializer.try_borrow_mut_lamports()? = ctx\n            .accounts\n            .initializer\n            .lamports()\n            .checked_add(amount)\n            .ok_or(EscrowError::AmountOverflow)?;\n\n        // Log transaction for registry\n        register_with_registry(\n            \"cancel\",\n            amount,\n            ctx.accounts.escrow.key().to_string(),\n            ctx.accounts.initializer.key().to_string(),\n        );\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\n#[instruction(amount: u64, release_condition: u64)]\npub struct Initialize<'info> {\n    #[account(mut)]\n    pub initializer: Signer<'info>,\n    /// CHECK: This is the recipient account that will receive funds\n    pub recipient: UncheckedAccount<'info>,\n    #[account(\n        init,\n        payer = initializer,\n        space = 8 + Escrow::SIZE,\n        seeds = [\n            b\"escrow\",\n            initializer.key().as_ref(),\n            recipient.key().as_ref(),\n            amount.to_le_bytes().as_ref(),\n            release_condition.to_le_bytes().as_ref(),\n        ],\n        bump\n    )]\n    pub escrow: Account<'info, Escrow>,\n    pub system_program: Program<'info, System>,\n    /// CHECK: Registry program for logging transactions\n    #[account(\n        constraint = registry_program.key() == REGISTRY_PROGRAM_ID @ EscrowError::InvalidRegistryProgram\n    )]\n    pub registry_program: UncheckedAccount<'info>,\n}\n\n#[derive(Accounts)]\npub struct Release<'info> {\n    /// CHECK: This is the recipient account that will receive funds\n    #[account(mut)]\n    pub recipient: UncheckedAccount<'info>,\n    #[account(\n        mut,\n        seeds = [\n            b\"escrow\",\n            escrow.initializer.as_ref(),\n            recipient.key().as_ref(),\n            escrow.amount.to_le_bytes().as_ref(),\n            escrow.release_condition.to_le_bytes().as_ref(),\n        ],\n        bump = escrow.bump,\n        constraint = escrow.recipient == recipient.key() @ EscrowError::InvalidRecipient,\n    )]\n    pub escrow: Account<'info, Escrow>,\n    pub system_program: Program<'info, System>,\n    /// CHECK: Registry program for logging transactions\n    #[account(\n        constraint = registry_program.key() == REGISTRY_PROGRAM_ID @ EscrowError::InvalidRegistryProgram\n    )]\n    pub registry_program: UncheckedAccount<'info>,\n}\n\n#[derive(Accounts)]\npub struct Cancel<'info> {\n    #[account(mut)]\n    pub initializer: Signer<'info>,\n    #[account(\n        mut,\n        seeds = [\n            b\"escrow\",\n            initializer.key().as_ref(),\n            escrow.recipient.as_ref(),\n            escrow.amount.to_le_bytes().as_ref(),\n            escrow.release_condition.to_le_bytes().as_ref(),\n        ],\n        bump = escrow.bump,\n        constraint = escrow.initializer == initializer.key() @ EscrowError::Unauthorized,\n    )]\n    pub escrow: Account<'info, Escrow>,\n    pub system_program: Program<'info, System>,\n    /// CHECK: Registry program for logging transactions\n    #[account(\n        constraint = registry_program.key() == REGISTRY_PROGRAM_ID @ EscrowError::InvalidRegistryProgram\n    )]\n    pub registry_program: UncheckedAccount<'info>,\n}\n\n#[account]\npub struct Escrow {\n    pub initializer: Pubkey,\n    pub recipient: Pubkey,\n    pub amount: u64,\n    pub release_condition: u64,\n    pub bump: u8,\n    pub is_completed: bool,\n}\n\nimpl Escrow {\n    pub const SIZE: usize = 32 + // initializer\n                            32 + // recipient\n                            8 +  // amount\n                            8 +  // release_condition\n                            1 +  // bump\n                            1;   // is_completed\n}\n\n#[error_code]\npub enum EscrowError {\n    #[msg(\"Escrow has already been completed\")]\n    AlreadyCompleted,\n    #[msg(\"Release condition has not been met\")]\n    ConditionNotMet,\n    #[msg(\"Unauthorized access to escrow\")]\n    Unauthorized,\n    #[msg(\"Invalid recipient for escrow\")]\n    InvalidRecipient,\n    #[msg(\"Amount calculation overflow\")]\n    AmountOverflow,\n    #[msg(\"Invalid registry program ID\")]\n    InvalidRegistryProgram,\n}\n\n// Registry program ID (fixed)\npub const REGISTRY_PROGRAM_ID: Pubkey = pubkey!(\"BhETt1LhzVYpK5DTcRuNZdKyb3QTz8HktUoXQJQapmvn\");\n\n// Helper function to log registry transactions\nfn register_with_registry(tx_type: &str, amount: u64, initiator: String, target_account: String) {\n    msg!(\n        \"Registry Transaction: type={}, amount={}, initiator={}, target={}\",\n        tx_type,\n        amount,\n        initiator,\n        target_account\n    );\n}", "deployed": false, "program_id": "8dfHZMcSAqoryDtza2qpHGqLEHy5c54M8qe7qTYQc1x6", "build_success": true}, "0435bfa0-bb54-463e-a92e-c58f67664300": {"type": "escrow", "name": "s", "parameters": {"amount": "1", "currency": "SOL", "release_condition": "3"}, "contract": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::{\n    program::invoke,\n    system_instruction,\n};\n\ndeclare_id!(\"HiGDqXXHuZ8kzEhS1zhSPU6QQg9RAsgwo7jv2QEY59j9\");\n\n#[program]\npub mod escrow {\n    use super::*;\n\n    pub fn initialize(\n        ctx: Context<Initialize>,\n        amount: u64,\n        release_condition: u64,\n    ) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        \n        // Initialize escrow data\n        escrow.initializer = ctx.accounts.initializer.key();\n        escrow.recipient = ctx.accounts.recipient.key();\n        escrow.amount = amount;\n        escrow.release_condition = release_condition;\n        escrow.bump = ctx.bumps.escrow;\n        escrow.is_completed = false;\n        \n        // Transfer funds from initializer to escrow account\n        let transfer_instruction = system_instruction::transfer(\n            &ctx.accounts.initializer.key(),\n            &ctx.accounts.escrow.to_account_info().key(),\n            amount,\n        );\n        \n        invoke(\n            &transfer_instruction,\n            &[\n                ctx.accounts.initializer.to_account_info(),\n                ctx.accounts.escrow.to_account_info(),\n                ctx.accounts.system_program.to_account_info(),\n            ],\n        )?;\n        \n        // Log transaction for registry\n        register_with_registry(\"initialize\", amount, ctx.accounts.initializer.key(), ctx.accounts.recipient.key());\n        \n        msg!(\"Escrow initialized with {} SOL\", amount);\n        Ok(())\n    }\n    \n    pub fn release(ctx: Context<Release>) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        \n        // Verify escrow is not already completed\n        require!(!escrow.is_completed, EscrowError::AlreadyCompleted);\n        \n        // Verify release condition is met\n        require!(\n            Clock::get()?.slot >= escrow.release_condition,\n            EscrowError::ReleaseConditionNotMet\n        );\n        \n        // Mark escrow as completed\n        escrow.is_completed = true;\n        \n        // Calculate the amount to transfer\n        let amount = escrow.amount;\n        \n        // Transfer funds from escrow to recipient\n        **ctx.accounts.escrow.to_account_info().try_borrow_mut_lamports()? = ctx\n            .accounts\n            .escrow\n            .to_account_info()\n            .lamports()\n            .checked_sub(amount)\n            .ok_or(EscrowError::AmountOverflow)?;\n            \n        **ctx.accounts.recipient.try_borrow_mut_lamports()? = ctx\n            .accounts\n            .recipient\n            .lamports()\n            .checked_add(amount)\n            .ok_or(EscrowError::AmountOverflow)?;\n        \n        // Log transaction for registry\n        register_with_registry(\"release\", amount, ctx.accounts.escrow.key(), ctx.accounts.recipient.key());\n        \n        msg!(\"Escrow released {} SOL to recipient\", amount);\n        Ok(())\n    }\n    \n    pub fn cancel(ctx: Context<Cancel>) -> Result<()> {\n        let escrow = &mut ctx.accounts.escrow;\n        \n        // Verify escrow is not already completed\n        require!(!escrow.is_completed, EscrowError::AlreadyCompleted);\n        \n        // Mark escrow as completed\n        escrow.is_completed = true;\n        \n        // Calculate the amount to transfer\n        let amount = escrow.amount;\n        \n        // Transfer funds from escrow back to initializer\n        **ctx.accounts.escrow.to_account_info().try_borrow_mut_lamports()? = ctx\n            .accounts\n            .escrow\n            .to_account_info()\n            .lamports()\n            .checked_sub(amount)\n            .ok_or(EscrowError::AmountOverflow)?;\n            \n        **ctx.accounts.initializer.try_borrow_mut_lamports()? = ctx\n            .accounts\n            .initializer\n            .lamports()\n            .checked_add(amount)\n            .ok_or(EscrowError::AmountOverflow)?;\n        \n        // Log transaction for registry\n        register_with_registry(\"cancel\", amount, ctx.accounts.escrow.key(), ctx.accounts.initializer.key());\n        \n        msg!(\"Escrow cancelled and {} SOL returned to initializer\", amount);\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\n#[instruction(amount: u64, release_condition: u64)]\npub struct Initialize<'info> {\n    #[account(mut)]\n    pub initializer: Signer<'info>,\n    \n    /// CHECK: This is the recipient of the escrow funds\n    pub recipient: AccountInfo<'info>,\n    \n    #[account(\n        init,\n        payer = initializer,\n        space = 8 + Escrow::SIZE,\n        seeds = [\n            b\"escrow\",\n            initializer.key().as_ref(),\n            recipient.key().as_ref(),\n            amount.to_le_bytes().as_ref(),\n        ],\n        bump\n    )]\n    pub escrow: Account<'info, Escrow>,\n    \n    pub system_program: Program<'info, System>,\n    \n    /// CHECK: This is the registry program\n    #[account(constraint = registry_program.key() == REGISTRY_PROGRAM_ID)]\n    pub registry_program: AccountInfo<'info>,\n}\n\n#[derive(Accounts)]\npub struct Release<'info> {\n    /// CHECK: This is the recipient of the escrow funds\n    #[account(mut)]\n    pub recipient: AccountInfo<'info>,\n    \n    #[account(\n        mut,\n        seeds = [\n            b\"escrow\",\n            escrow.initializer.as_ref(),\n            escrow.recipient.as_ref(),\n            escrow.amount.to_le_bytes().as_ref(),\n        ],\n        bump = escrow.bump,\n        constraint = escrow.recipient == recipient.key() @ EscrowError::InvalidRecipient,\n    )]\n    pub escrow: Account<'info, Escrow>,\n    \n    pub system_program: Program<'info, System>,\n    \n    /// CHECK: This is the registry program\n    #[account(constraint = registry_program.key() == REGISTRY_PROGRAM_ID)]\n    pub registry_program: AccountInfo<'info>,\n}\n\n#[derive(Accounts)]\npub struct Cancel<'info> {\n    #[account(mut)]\n    pub initializer: Signer<'info>,\n    \n    #[account(\n        mut,\n        seeds = [\n            b\"escrow\",\n            escrow.initializer.as_ref(),\n            escrow.recipient.as_ref(),\n            escrow.amount.to_le_bytes().as_ref(),\n        ],\n        bump = escrow.bump,\n        constraint = escrow.initializer == initializer.key() @ EscrowError::InvalidInitializer,\n    )]\n    pub escrow: Account<'info, Escrow>,\n    \n    pub system_program: Program<'info, System>,\n    \n    /// CHECK: This is the registry program\n    #[account(constraint = registry_program.key() == REGISTRY_PROGRAM_ID)]\n    pub registry_program: AccountInfo<'info>,\n}\n\n#[account]\npub struct Escrow {\n    pub initializer: Pubkey,\n    pub recipient: Pubkey,\n    pub amount: u64,\n    pub release_condition: u64,\n    pub is_completed: bool,\n    pub bump: u8,\n}\n\nimpl Escrow {\n    pub const SIZE: usize = 32 + // initializer\n                            32 + // recipient\n                            8 +  // amount\n                            8 +  // release_condition\n                            1 +  // is_completed\n                            1;   // bump\n}\n\n#[error_code]\npub enum EscrowError {\n    #[msg(\"Escrow has already been completed\")]\n    AlreadyCompleted,\n    \n    #[msg(\"Release condition has not been met\")]\n    ReleaseConditionNotMet,\n    \n    #[msg(\"Invalid recipient\")]\n    InvalidRecipient,\n    \n    #[msg(\"Invalid initializer\")]\n    InvalidInitializer,\n    \n    #[msg(\"Amount overflow\")]\n    AmountOverflow,\n}\n\n// Registry program ID\npub const REGISTRY_PROGRAM_ID: Pubkey = pubkey!(\"BhETt1LhzVYpK5DTcRuNZdKyb3QTz8HktUoXQJQapmvn\");\n\n// Helper function to log registry transactions\nfn register_with_registry(tx_type: &str, amount: u64, initiator: Pubkey, target_account: Pubkey) {\n    msg!(\n        \"Registry Transaction: type={}, amount={}, initiator={}, target={}\",\n        tx_type,\n        amount,\n        initiator,\n        target_account\n    );\n}", "deployed": false, "program_id": "HiGDqXXHuZ8kzEhS1zhSPU6QQg9RAsgwo7jv2QEY59j9", "build_success": true}, "341e9ffc-69ef-4eef-9859-56b0641669a8": {"type": "escrow", "name": "s", "parameters": {"amount": "1", "currency": "SOL", "release_condition": "1"}, "contract": "\n        use anchor_lang::prelude::*;\n        \n        declare_id!(\"FxcVNTC1KkUeTTbdzNnGvBZBdE5XFxW5WrzMawawpdYc\");\n        \n        #[program]\n        pub mod deploy {\n            use super::*;\n            \n            pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n                Ok(())\n            }\n        }\n        \n        #[derive(Accounts)]\n        pub struct Initialize<'info> {\n            #[account(mut)]\n            pub signer: Signer<'info>,\n            pub system_program: Program<'info, System>,\n        }\n        ", "deployed": false, "program_id": "FxcVNTC1KkUeTTbdzNnGvBZBdE5XFxW5WrzMawawpdYc", "build_success": true}, "28a2b1ee-83d7-4cb4-b8d8-89e6f0508c36": {"type": "escrow", "name": "testing", "parameters": {"amount": "1", "currency": "SOL", "release_condition": "3"}, "contract": "\n        use anchor_lang::prelude::*;\n        \n        declare_id!(\"7h3nZshfG5ASJV1ZJ9HGsU7rqWATzLih4aMEcGrLvCXd\");\n        \n        #[program]\n        pub mod deploy {\n            use super::*;\n            \n            pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n                Ok(())\n            }\n        }\n        \n        #[derive(Accounts)]\n        pub struct Initialize<'info> {\n            #[account(mut)]\n            pub signer: Signer<'info>,\n            pub system_program: Program<'info, System>,\n        }\n        ", "deployed": false, "program_id": "7h3nZshfG5ASJV1ZJ9HGsU7rqWATzLih4aMEcGrLvCXd", "build_success": true}}